---
apiVersion: metacontroller.k8s.io/v1alpha1
kind: DecoratorController
metadata:
  name: tenant-secret-controller
spec:
  resources:
    - apiVersion: minio.min.io/v2
      resource: tenants
  attachments:
    - apiVersion: v1
      resource: secrets
      updateStrategy:
        method: Recreate
  hooks:
    # customize:
    #   webhook:
    #     url: http://tenant-webhook.operators.svc.cluster.local/customize
    sync:
      webhook:
        url: http://tenant-webhook.operators.svc.cluster.local/sync
---
apiVersion: v1
kind: Service
metadata:
  name: tenant-webhook
  namespace: operators
spec:
  selector:
    app: tenant-webhook
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tenant-webhook
  namespace: operators
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tenant-webhook
  template:
    metadata:
      labels:
        app: tenant-webhook
    spec:
      containers:
        - name: tenant-webhook
          image: docker.io/library/python:3.12
          command:
          - python3
          - -c
          args:
          - |
            import base64
            import inspect
            import json
            import os
            import secrets
            from http.server import BaseHTTPRequestHandler, HTTPServer

            class WebhookHandler(BaseHTTPRequestHandler):
              def _get_request(self):
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                return json.loads(post_data)

              def _customize(self, request):
                pass

              def _sync(self, request):
                if os.environ.get("DEBUG") == "true":
                  print(json.dumps(request, indent=2))

                secret_name = request.get("object", {}).get("spec", {}).get("configuration", {}).get("name", "storage-configuration")
                secret_attachments = request.get("attachments", {}).get("Secret.v1", {})
                if len(secret_attachments) == 1:
                  secret_data = list(secret_attachments.values())[0]["data"]
                else:
                  root_user = base64.b32encode(secrets.token_bytes(15)).decode("ascii")
                  root_password = base64.b64encode(secrets.token_bytes(36)).decode("ascii")

                  minio_config = inspect.cleandoc(f"""
                  export MINIO_ROOT_USER="{root_user}"
                  export MINIO_ROOT_PASSWORD="{root_password}"
                  export MINIO_STORAGE_CLASS_STANDARD="EC:2"
                  export MINIO_BROWSER="on"
                  """)

                  secret_data = {'config.env': base64.b64encode(minio_config.encode("utf-8")).decode('utf-8')}

                # Create the Secret object as a dictionary
                secret = {
                    'apiVersion': 'v1',
                    'kind': 'Secret',
                    'metadata': {
                        'name': secret_name,
                    },
                    'data': secret_data,
                }

                # Prepare the response
                response = {
                    'attachments': [secret]
                }
                response_data = json.dumps(response).encode('utf-8')

                # Send HTTP response headers
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()

                # Write the response data
                self.wfile.write(response_data)
                if os.environ.get("DEBUG") == "true":
                  print(response_data)
                
              def do_POST(self):
                  # if self.path == "/customize":
                  #   return self._customize(self._get_request())
                  if self.path == "/sync":
                    return self._sync(self._get_request())
                  
                  self.send_response(400)
                
            HTTPServer(("", 8080), WebhookHandler).serve_forever()
          ports:
            - containerPort: 8080